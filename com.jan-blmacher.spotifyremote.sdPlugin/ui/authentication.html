<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8" />
    <script src="streamdeck-connection.js"></script>
    <script src="sdpi-components.js"></script>
</head>
<body>
    <sdpi-item label="">
        <details class="sdpi-item-value">
            <summary><strong>Spotify Authentication</strong></summary>
            
            <sdpi-item label="Client ID">
                <sdpi-textfield 
                    id="clientId"
                    placeholder="Your Spotify Client ID">
                </sdpi-textfield>
            </sdpi-item>

            <sdpi-item label="Client Secret">
                <sdpi-password 
                    id="clientSecret"
                    placeholder="Your Spotify Client Secret">
                </sdpi-password>
            </sdpi-item>

            <sdpi-item label="">
                <sdpi-button id="authenticateBtn">Authenticate with Spotify</sdpi-button>
            </sdpi-item>

            <br>
            <p><strong>How to authenticate:</strong></p>
            <ol>
                <li>Enter your Spotify Client ID and Secret above</li>
                <li>Click "Authenticate with Spotify"</li>
                <li>Authorize the app in your browser</li>
                <li><strong>Tokens will be saved automatically!</strong></li>
            </ol>
            <p><strong>Note:</strong> A local server will temporarily run on your machine to receive the authorization. This is secure and only runs during authentication.</p>
            <p><strong>Important:</strong> Make sure your Spotify App settings include <code>http://127.0.0.1:8888/callback</code> as a Redirect URI!</p>
        </details>
    </sdpi-item>

    <script>
        const { streamDeckClient } = SDPIComponents;
        
        // Store reference to elements
        let authenticateBtn = null;
        let importBtn = null;
        let importStringTextarea = null;
        let clientIdInput = null;
        let clientSecretInput = null;

        // Function to save to global settings
        async function saveToGlobalSettings(key, value) {
            try {
                // Get current settings first
                const currentSettings = await new Promise((resolve) => {
                    window.$SD.api.getGlobalSettings(window.$SD.pluginUUID, (settings) => {
                        resolve(settings || {});
                    });
                });
                
                const newSettings = {
                    ...currentSettings,
                    [key]: value
                };
                
                window.$SD.api.setGlobalSettings(window.$SD.pluginUUID, newSettings);
                console.log(`[Auth] Saved ${key} to global settings`);
            } catch (error) {
                console.error(`[Auth] Error saving ${key}:`, error);
            }
        }

        // Function to load from global settings
        async function loadGlobalSettings() {
            try {
                console.log('[Auth] Loading global settings...');
                
                // Use our custom $SD API - the callback receives the settings object directly
                const settings = await new Promise((resolve) => {
                    window.$SD.api.getGlobalSettings(window.$SD.pluginUUID, (settingsData) => {
                        console.log('[Auth] getGlobalSettings callback received:', settingsData);
                        // The callback already receives just the settings object
                        resolve(settingsData || {});
                    });
                });
                
                console.log('[Auth] Loaded global settings:', settings);
                
                if (clientIdInput && settings.clientId) {
                    console.log('[Auth] Setting clientId input to:', settings.clientId.substring(0, 8) + '...');
                    clientIdInput.value = settings.clientId;
                }
                if (clientSecretInput && settings.clientSecret) {
                    console.log('[Auth] Setting clientSecret input (has value)');
                    clientSecretInput.value = settings.clientSecret;
                }
            } catch (error) {
                console.error('[Auth] Error loading settings:', error);
            }
        }

        // Wait for DOM to be ready
        document.addEventListener('DOMContentLoaded', async function() {
            console.log('[Auth] DOM Content Loaded');
            
            // Wait for custom elements to be ready
            await new Promise(resolve => setTimeout(resolve, 100));
            
            authenticateBtn = document.getElementById('authenticateBtn');
            importBtn = document.getElementById('importBtn');
            importStringTextarea = document.getElementById('importString');
            clientIdInput = document.getElementById('clientId');
            clientSecretInput = document.getElementById('clientSecret');

            console.log('[Auth] authenticateBtn:', authenticateBtn);
            console.log('[Auth] clientIdInput:', clientIdInput);
            console.log('[Auth] clientSecretInput:', clientSecretInput);

            // Load existing settings
            await loadGlobalSettings();

            // Save Client ID on change
            clientIdInput?.addEventListener('change', function() {
                console.log('[Auth] Client ID changed');
                saveToGlobalSettings('clientId', clientIdInput.value.trim());
            });

            // Save Client Secret on change
            clientSecretInput?.addEventListener('change', function() {
                console.log('[Auth] Client Secret changed');
                saveToGlobalSettings('clientSecret', clientSecretInput.value.trim());
            });

            // Handle authenticate button
            if (authenticateBtn) {
                console.log('[Auth] Attaching click handler to authenticate button');
                authenticateBtn.addEventListener('click', async function() {
                    console.log('[Auth] *** AUTHENTICATE BUTTON CLICKED ***');
                }, { capture: true });
            } else {
                console.error('[Auth] ❌ Authenticate button not found!');
            }
            
            authenticateBtn?.addEventListener('click', async function() {
                try {
                    const clientId = clientIdInput?.value?.trim();
                    const clientSecret = clientSecretInput?.value?.trim();

                    if (!clientId || !clientSecret) {
                        alert('Please enter both Client ID and Client Secret first');
                        return;
                    }

                    // Disable button and show loading state
                    authenticateBtn.disabled = true;
                    const originalText = authenticateBtn.textContent;
                    authenticateBtn.textContent = 'Starting authentication...';
                    console.log('[Auth] Button disabled, starting authentication flow...');

                    // Save credentials before opening auth
                    await saveToGlobalSettings('clientId', clientId);
                    await saveToGlobalSettings('clientSecret', clientSecret);

                    console.log('Credentials saved, sending message to start OAuth server...');

                    // Send message to plugin using streamDeckClient
                    try {
                        // Access the underlying connection from SDPIComponents
                        if (window.$SD && window.$SD.connection) {
                            console.log('Using window.$SD.connection...');
                            window.$SD.connection.send(JSON.stringify({
                                event: 'sendToPlugin',
                                context: window.$SD.uuid,
                                payload: {
                                    event: 'startOAuthServer',
                                    payload: {
                                        clientId: clientId,
                                        clientSecret: clientSecret
                                    }
                                }
                            }));
                            console.log('✓ Message sent to plugin via $SD.connection');
                        } else {
                            console.error('❌ window.$SD.connection not available!');
                            console.log('Attempting to send via streamDeckClient internal connection...');
                            
                            // Try to access the internal connection from streamDeckClient
                            const internalConnection = streamDeckClient?.__connection;
                            if (internalConnection) {
                                console.log('Using streamDeckClient.__connection...');
                                internalConnection.send(JSON.stringify({
                                    event: 'sendToPlugin',
                                    context: streamDeckClient.__context,
                                    payload: {
                                        event: 'startOAuthServer',
                                        payload: {
                                            clientId: clientId,
                                            clientSecret: clientSecret
                                        }
                                    }
                                }));
                                console.log('✓ Message sent via internal connection');
                            } else {
                                console.error('❌ No connection available!');
                                console.log('window.$SD:', window.$SD);
                                console.log('streamDeckClient:', streamDeckClient);
                                
                                // Re-enable button
                                authenticateBtn.disabled = false;
                                authenticateBtn.textContent = originalText || 'Authenticate with Spotify';
                                
                                alert('Error: Cannot communicate with plugin. Please check the Stream Deck logs.');
                                return;
                            }
                        }
                    } catch (error) {
                        console.error('Error sending message:', error);
                        
                        // Re-enable button
                        authenticateBtn.disabled = false;
                        authenticateBtn.textContent = originalText || 'Authenticate with Spotify';
                        
                        alert('Error sending message to plugin: ' + error.message);
                        return;
                    }

                    console.log('Message sent to plugin, waiting for server to start...');

                    // Wait for server to start (2 seconds should be enough)
                    await new Promise(resolve => setTimeout(resolve, 2000));
                    
                    // Try to verify server is running by making a test request
                    try {
                        console.log('Testing if server is running...');
                        const testResponse = await fetch('http://127.0.0.1:8888/', { method: 'HEAD' }).catch(() => null);
                        if (testResponse) {
                            console.log('✓ Server is running!');
                        } else {
                            console.warn('⚠ Server might not be running yet...');
                        }
                    } catch (e) {
                        console.warn('Could not verify server status');
                    }

                    console.log('Opening Spotify authorization page...');
                    
                    // Update button text
                    authenticateBtn.textContent = 'Waiting for authorization...';

                    const scopes = [
                        'user-read-playback-state',
                        'user-modify-playback-state',
                        'user-read-currently-playing',
                        'user-library-modify'
                    ].join(' ');

                    // Use 127.0.0.1 callback (Spotify no longer allows localhost as of this month)
                    const authUrl = 'https://accounts.spotify.com/authorize?' +
                        'client_id=' + encodeURIComponent(clientId) + '&' +
                        'response_type=code&' +
                        'redirect_uri=' + encodeURIComponent('http://127.0.0.1:8888/callback') + '&' +
                        'scope=' + encodeURIComponent(scopes);

                    // Try multiple methods to open URL
                    if (streamDeckClient && streamDeckClient.openUrl) {
                        streamDeckClient.openUrl(authUrl);
                    } else {
                        window.open(authUrl, '_blank');
                    }
                } catch (error) {
                    console.error('[Auth] Authentication error:', error);
                    
                    // Re-enable button on error
                    authenticateBtn.disabled = false;
                    authenticateBtn.textContent = originalText || 'Authenticate with Spotify';
                    
                    alert('Error starting authentication: ' + error.message + '\n\nCheck the Stream Deck logs for details.');
                }
            });

            // Handle import button (kept for backwards compatibility / manual entry)
            importBtn?.addEventListener('click', async function() {
                try {
                    const importString = importStringTextarea?.value?.trim();
                    
                    if (!importString) {
                        alert('Please paste the import string first');
                        return;
                    }

                    let parsedTokens = null;

                    // Try parsing as JSON
                    try {
                        const tokens = JSON.parse(importString);
                        if (tokens.accessToken && tokens.refreshToken) {
                            parsedTokens = {
                                accessToken: tokens.accessToken,
                                refreshToken: tokens.refreshToken,
                                clientId: tokens.clientId,
                                clientSecret: tokens.clientSecret
                            };
                        } else if (tokens.access_token && tokens.refresh_token) {
                            parsedTokens = {
                                accessToken: tokens.access_token,
                                refreshToken: tokens.refresh_token,
                                clientId: tokens.client_id,
                                clientSecret: tokens.client_secret
                            };
                        }
                    } catch (jsonError) {
                        // Try URL params
                        const urlParams = new URLSearchParams(importString);
                        const accessToken = urlParams.get('accessToken') || urlParams.get('access_token');
                        const refreshToken = urlParams.get('refreshToken') || urlParams.get('refresh_token');
                        
                        if (accessToken && refreshToken) {
                            parsedTokens = {
                                accessToken: accessToken,
                                refreshToken: refreshToken
                            };
                        } else {
                            // Try base64
                            try {
                                const decoded = atob(importString);
                                const tokens = JSON.parse(decoded);
                                if (tokens.accessToken && tokens.refreshToken) {
                                    parsedTokens = tokens;
                                }
                            } catch (base64Error) {
                                alert('Could not parse import string. Please check the format.');
                                return;
                            }
                        }
                    }

                    if (!parsedTokens || !parsedTokens.accessToken || !parsedTokens.refreshToken) {
                        alert('Invalid token format. Please check the import string.');
                        return;
                    }

                    // Get current settings and merge
                    const currentSettings = await streamDeckClient.getSettings();
                    const newSettings = {
                        ...currentSettings,
                        ...parsedTokens
                    };

                    // Save to global settings
                    await streamDeckClient.setGlobalSettings(newSettings);
                    
                    // Clear the textarea
                    importStringTextarea.value = '';
                    
                    alert('Tokens imported successfully!');
                } catch (error) {
                    console.error('Import error:', error);
                    alert('Error importing tokens: ' + error.message);
                }
            });
        });
    </script>
</body>
</html>
